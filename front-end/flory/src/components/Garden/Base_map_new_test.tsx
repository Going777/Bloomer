/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 ./public/models/base_map_new.glb -t
*/

import * as THREE from "three";
import React, { useRef } from "react";
import { useGLTF, OrthographicCamera } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    Water: THREE.Mesh;
    Base_Ground: THREE.Mesh;
    Tree2: THREE.Mesh;
    Cube: THREE.Mesh;
    Cube001: THREE.Mesh;
    Cube002: THREE.Mesh;
    Cube003: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube005: THREE.Mesh;
    Cube006: THREE.Mesh;
    Cube007: THREE.Mesh;
    Cube008: THREE.Mesh;
    Cube009: THREE.Mesh;
    Bench: THREE.Mesh;
    Vert001: THREE.Mesh;
    Vert002: THREE.Mesh;
    Circle001: THREE.Mesh;
    Circle001_1: THREE.Mesh;
    Tree1: THREE.Mesh;
    Cube033: THREE.Mesh;
    Cube035: THREE.Mesh;
    Cube036: THREE.Mesh;
    Cube037: THREE.Mesh;
    Cube038: THREE.Mesh;
    Cube039: THREE.Mesh;
    Cube040: THREE.Mesh;
    Cube041: THREE.Mesh;
    Cube042: THREE.Mesh;
    Cube043: THREE.Mesh;
    Circle001_2: THREE.Mesh;
    Circle001_3: THREE.Mesh;
    Rock004: THREE.Mesh;
    Grass005: THREE.Mesh;
    Grass006: THREE.Mesh;
    Bg: THREE.Mesh;
    Base_Grass: THREE.Mesh;
    Rock006: THREE.Mesh;
    Grass012: THREE.Mesh;
    Grass014: THREE.Mesh;
    Grass015: THREE.Mesh;
  };
  materials: {
    Water: THREE.MeshStandardMaterial;
    Ground: THREE.MeshStandardMaterial;
    Tree: THREE.MeshStandardMaterial;
    leaf2: THREE.MeshStandardMaterial;
    Wood: THREE.MeshStandardMaterial;
    Metal: THREE.MeshStandardMaterial;
    Light: THREE.MeshStandardMaterial;
    Rock: THREE.MeshStandardMaterial;
    ["Grass.001"]: THREE.MeshStandardMaterial;
    Bg: THREE.MeshStandardMaterial;
    Grass: THREE.MeshStandardMaterial;
  };
};

export function Model_new_test(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/models/base_map_new.glb"
  ) as GLTFResult;

  const { scene, camera, gl } = useThree();

  const raycaster = new THREE.Raycaster();
  const clickMouse = new THREE.Vector2();
  const moveMouse = new THREE.Vector2();

  let draggable: THREE.Object3D;

  function intersect(pos: THREE.Vector2) {
    raycaster.setFromCamera(pos, camera);
    return raycaster.intersectObjects(scene.children);
  }

  window.addEventListener("click", (event) => {
    if (draggable != null) {
      console.log(`dropping draggable ${draggable.userData.name}`);
      draggable = null as any;
      return;
    }

    const rect = gl.domElement.getBoundingClientRect();

    // 1
    // clickMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    // clickMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    // 2
    // THREE RAYCASTER
    // clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    // clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // 3 이론상 이게 맞을 것 같은데...
    clickMouse.x =
      ((event.clientX - rect.left) / (rect.right - rect.left)) * 2 - 1;
    clickMouse.y = -(event.clientY / rect.height) * 2 + 1;

    // console.log(event.clientX, event.clientX - rect.left, "비교");
    console.log(clickMouse.x, clickMouse.y, "비교");

    const found = intersect(clickMouse);
    if (found.length > 0) {
      if (found[0].object.userData.draggable) {
        draggable = found[0].object;
        console.log(`found draggable ${draggable.userData.name}`);
      }
    }
  });

  const app = document.querySelector(".app");
  console.log(app?.getBoundingClientRect().width);
  let a = app?.getBoundingClientRect().width;
  let b = app?.getBoundingClientRect().height;

  window.addEventListener("mousemove", (event) => {
    moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // console.log(event.clientX, window.innerWidth, "가로");
    // console.log(event.clientY, window.innerHeight, "세로");
    // console.log(moveMouse.x, moveMouse.y);
  });

  window.addEventListener("touchmove", (event) => {
    moveMouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
    moveMouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
  });

  function dragObject() {
    if (draggable != null) {
      const found = intersect(moveMouse);
      if (found.length > 0) {
        for (let i = 0; i < found.length; i++) {
          if (!found[i].object.userData.ground) continue;

          let target = found[i].point;
          draggable.position.x = target.x;
          draggable.position.z = target.z;
        }
      }
    }
  }

  function animate() {
    dragObject();
    requestAnimationFrame(animate);
  }

  animate();

  // window.addEventListener("click", (event) => {
  //   clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  //   clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // });

  const ref = useRef(null);

  // const handlePointerDown = (event: any) => {
  //   event.stopPropagation();
  //   ref.current.userData.draggable = true;
  // };

  return (
    <group {...props} dispose={null}>
      <OrthographicCamera
        makeDefault={true}
        far={1000}
        near={0.1}
        position={[30.37, 31.24, 30.16]}
        rotation={[-0.79, 0.62, 0.52]}
        zoom={50}
      />

      <pointLight
        intensity={5}
        decay={2}
        color="#ff6728"
        position={[-3.77, 2.82, -1.77]}
        rotation={[-Math.PI / 2, 0, -Math.PI]}
      />
      <pointLight
        intensity={5}
        decay={2}
        color="#ff6728"
        position={[3.14, 2.92, -3.19]}
        rotation={[-Math.PI / 2, 0, -Math.PI]}
      />
      <directionalLight
        // ref={directionalLightRef1}
        position={[0, 10, -1]}
        intensity={0.1}
        color="#53288f"
        castShadow
      />
      <directionalLight
        // ref={directionalLightRef2}
        position={[-7, 3, 10]}
        intensity={0.4}
        color="#6a00ff"
      />

      <mesh
        geometry={nodes.Water.geometry}
        material={materials.Water}
        position={[-0.39, 0.23, 5.45]}
        rotation={[Math.PI, 0, Math.PI]}
      />
      <mesh
        geometry={nodes.Base_Ground.geometry}
        material={materials.Ground}
        position={[-0.3, 0.15, 0.19]}
        rotation={[Math.PI, 0, Math.PI]}
      />

      <mesh
        geometry={nodes.Tree2.geometry}
        material={materials.Tree}
        position={[-1.9, 0.07, -3.45]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={0.5}
      >
        <mesh
          geometry={nodes.Cube.geometry}
          material={materials.leaf2}
          position={[-0.07, 2.27, 0.05]}
          rotation={[0.16, 0.01, 0.03]}
          scale={0.65}
        />
        <mesh
          geometry={nodes.Cube001.geometry}
          material={materials.leaf2}
          position={[0.57, 2.04, 0.04]}
          rotation={[3.11, 0.12, -1.32]}
          scale={0.6}
        />
        <mesh
          geometry={nodes.Cube002.geometry}
          material={materials.leaf2}
          position={[0.7, 1.35, 0]}
          rotation={[-3.11, 1.18, -1.45]}
          scale={0.81}
        />
        <mesh
          geometry={nodes.Cube003.geometry}
          material={materials.leaf2}
          position={[-0.28, 1.94, -0.49]}
          rotation={[-3.11, 1.18, -1.45]}
          scale={0.68}
        />
        <mesh
          geometry={nodes.Cube004.geometry}
          material={materials.leaf2}
          position={[-0.45, 1.41, 0.66]}
          rotation={[0.67, 0.67, 1.01]}
          scale={0.5}
        />
        <mesh
          geometry={nodes.Cube005.geometry}
          material={materials.leaf2}
          position={[-0.24, 1.83, 0.45]}
          rotation={[0.15, 0.01, 1.56]}
          scale={0.45}
        />
        <mesh
          geometry={nodes.Cube006.geometry}
          material={materials.leaf2}
          position={[-0.59, 1.43, -0.06]}
          rotation={[0.35, -0.27, 1.53]}
          scale={0.63}
        />
        <mesh
          geometry={nodes.Cube007.geometry}
          material={materials.leaf2}
          position={[0.16, 1.28, 0.6]}
          rotation={[2.51, -0.88, 3]}
          scale={0.81}
        />
        <mesh
          geometry={nodes.Cube008.geometry}
          material={materials.leaf2}
          position={[0.2, 1.39, -0.47]}
          rotation={[1.38, -0.51, 1.28]}
          scale={0.74}
        />
        <mesh
          geometry={nodes.Cube009.geometry}
          material={materials.leaf2}
          position={[0.17, 1.8, 0.33]}
          rotation={[-0.32, 0.62, 1.81]}
          scale={0.53}
        />
      </mesh>
      <mesh
        geometry={nodes.Bench.geometry}
        material={materials.Wood}
        position={[-1.99, -0.11, -2.3]}
        rotation={[0, 0.59, 0]}
        scale={0.67}
        castShadow={true}
        receiveShadow={true}
      >
        <mesh geometry={nodes.Vert001.geometry} material={materials.Metal} />
        <mesh geometry={nodes.Vert002.geometry} material={materials.Metal} />
      </mesh>
      <group
        position={[-3.76, 0.01, -1.81]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={0.96}
      >
        <mesh
          geometry={nodes.Circle001.geometry}
          material={materials.Metal}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Circle001_1.geometry}
          material={materials.Light}
          castShadow={true}
          receiveShadow={true}
        />
      </group>
      <mesh
        geometry={nodes.Tree1.geometry}
        material={materials.Tree}
        position={[-3.19, 0.12, -3.15]}
        rotation={[0, -0.12, 0]}
        scale={0.79}
        castShadow={true}
        receiveShadow={true}
        ref={ref}
        userData={{ draggable: true, name: "bench" }}
      >
        <mesh
          geometry={nodes.Cube033.geometry}
          material={materials.leaf2}
          position={[-0.07, 2.27, 0.05]}
          rotation={[0.16, 0.01, 0.03]}
          scale={0.65}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube035.geometry}
          material={materials.leaf2}
          position={[0.57, 2.04, 0.04]}
          rotation={[3.11, 0.12, -1.32]}
          scale={0.6}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube036.geometry}
          material={materials.leaf2}
          position={[0.7, 1.35, 0]}
          rotation={[-3.11, 1.18, -1.45]}
          scale={0.81}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube037.geometry}
          material={materials.leaf2}
          position={[-0.28, 1.94, -0.49]}
          rotation={[-3.11, 1.18, -1.45]}
          scale={0.68}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube038.geometry}
          material={materials.leaf2}
          position={[-0.45, 1.41, 0.66]}
          rotation={[0.67, 0.67, 1.01]}
          scale={0.5}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube039.geometry}
          material={materials.leaf2}
          position={[-0.24, 1.83, 0.45]}
          rotation={[0.15, 0.01, 1.56]}
          scale={0.45}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube040.geometry}
          material={materials.leaf2}
          position={[-0.59, 1.43, -0.06]}
          rotation={[0.35, -0.27, 1.53]}
          scale={0.63}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube041.geometry}
          material={materials.leaf2}
          position={[0.16, 1.28, 0.6]}
          rotation={[2.51, -0.88, 3]}
          scale={0.81}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube042.geometry}
          material={materials.leaf2}
          position={[0.2, 1.39, -0.47]}
          rotation={[1.38, -0.51, 1.28]}
          scale={0.74}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Cube043.geometry}
          material={materials.leaf2}
          position={[0.17, 1.8, 0.33]}
          rotation={[-0.32, 0.62, 1.81]}
          scale={0.53}
          castShadow={true}
          receiveShadow={true}
        />
      </mesh>
      <group
        position={[3.14, 0.01, -3.16]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={0.97}
      >
        <mesh
          geometry={nodes.Circle001_2.geometry}
          material={materials.Metal}
          castShadow={true}
          receiveShadow={true}
        />
        <mesh
          geometry={nodes.Circle001_3.geometry}
          material={materials.Light}
          castShadow={true}
          receiveShadow={true}
        />
      </group>
      <mesh
        geometry={nodes.Rock004.geometry}
        material={materials.Rock}
        position={[2.95, 0.05, 1.8]}
        rotation={[-Math.PI, 0, 0]}
        scale={[1.3, 0.67, 1]}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Grass005.geometry}
        material={materials["Grass.001"]}
        position={[2.4, 0.03, 2.27]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={1.27}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Grass006.geometry}
        material={materials["Grass.001"]}
        position={[-3.19, 0.05, 1.03]}
        rotation={[Math.PI, -0.68, Math.PI]}
        scale={1.6}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Bg.geometry}
        material={materials.Bg}
        position={[0, -0.94, -0.01]}
        scale={[-138.53, -24.88, -138.53]}
        // castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Base_Grass.geometry}
        material={materials.Grass}
        position={[-0.31, -0.15, 4.52]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={[1, 1, 2.09]}
        // castShadow={true}
        receiveShadow={true}
        userData={{ ground: true }}
      />
      <mesh
        geometry={nodes.Rock006.geometry}
        material={materials.Rock}
        position={[-2.44, 0.03, 3.6]}
        rotation={[-Math.PI, 0, 0]}
        scale={0.86}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Grass012.geometry}
        material={materials["Grass.001"]}
        position={[0.62, -0.01, 1.47]}
        rotation={[-Math.PI, 0.94, -Math.PI]}
        scale={1.27}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Grass014.geometry}
        material={materials["Grass.001"]}
        position={[3.4, 0, 0.93]}
        rotation={[Math.PI, -0.8, Math.PI]}
        scale={1.77}
        castShadow={true}
        receiveShadow={true}
      />
      <mesh
        geometry={nodes.Grass015.geometry}
        material={materials["Grass.001"]}
        position={[1.29, 0.03, -2.49]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={1.65}
        castShadow={true}
        receiveShadow={true}
      />
    </group>
  );
}

// useGLTF.preload("/base_map_new.glb");

function Base_map_new_test() {
  return (
    // object3D: 빈 지역 공간
    <Model_new_test />
  );
}

export default Base_map_new_test;
